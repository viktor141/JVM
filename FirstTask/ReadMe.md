# Задача "Понимание JVM"



```java
public class JvmComprehension {

	public static void main(String[] args) {
		int i = 1;                      // 1
		Object o = new Object();        // 2
		Integer ii = 2;                 // 3
		printAll(o, i, ii);             // 4
		System.out.println("finished"); // 7
	}

	private static void printAll(Object o, int i, Integer ii) {
		Integer uselessVar = 700;                   // 5
		System.out.println(o.toString() + i + ii);  // 6
	}
}
```



	1.
		1. Начинается этап ClassLoader'ов
			1. Вызывается Application ClassLoader.
			2. Он же, прежде чем что то сделать вызывает Platform ClassLoader.
			3. Который в свою очеред для начала вызывает Bootsrap ClassLoader.
			4. Bootsrap ClassLoader уже начинает отвечая за свои классы, загружать их в память.
			5. Если загрузка произошла удачно, он отдает команду уже Platform ClassLoader.
			6. Platform ClassLoader уже отвечает за классы, которые небходимы на той или иной платформе.
			Так как java кроссплатформенный язык.
			Для нормальной работы ему необходима реализация на разных платформах в зависимости с спецификацией
			7. И если этап Platform ClassLoader загрузил все, он говорит об этом Application ClassLoader'у
			8. Application ClassLoader отвечает за классы нашего приложения, что написали мы. Начиная загружать их в память.
<img src="/Resources/ClassLoaders.png"></img>

		2. Уже после всех предыдущих пунктов начинается этап называемый "Связывание".
		Где три этапа идут друг за другом
			1. Проверка, что код валиден.
			2. Подгоовка примитивов в статических полях.
			3. Связывание ссылок на другие классы
<img src="/Resources/Linking.png"></img>

		3. И вот только здесь, происходит Инициализация.
		Инициализация статик полей и статик инициализаторов.



	2. Следующий этап Runtime Data Area
		1. Все классы что были найдены, были загружены в Meta space. Здесь хранятся данные о классах, поля, методы, константы.
<img src="/Resources/MetaMem.png"></img>


	3. Здесь начинается работа Stack Memory и Heap Memory.
	Первый пункт это перввая  строчка кода и т.д.

		1. Происходит запись примитивного типа данных int в созданный фрэйм методом main().
<img src="/Resources/StackMem.png" height="400"></img>

		2. В куче вделяется место для объекта Object и в стэк записывыется ссылка на этот объект в куче.
<img src="/Resources/HeapMem.png"></img>

		3. Integer это класс враппер, так как ет ключевого слова new, то он сохраняется так же как и простой int в стэк;

		4. Вызывается новый метод printAll() с нашими параметрами.
			1. в стэке создается новый фрейм. Почти так же как foo(), только printAll().
<img src="/Resources/Stack+1.png"></img>

			2. Указатель перемщается на него, начиная выполнять те команды что записаны внутри этого метода.
			3. А так же при создании фрейма в него сразу записываются три переменные, две примитивного типа int со значениями, А третья переменная ссылочного типа которая содержит ссылку на участок памяти в куче, где находится Object.


		5. В фрейме printAll Выделяется память под перемную примитивного типа int.

		6. Происходит создание еще одного фрейма по имени println(),
			1. В котором мы так же передаем параметры в виде тех же двух примитивных переменных типа инт.
			2. Так как toString создает новый объект String() то ссылка на него передается в этот новый фрейм println().


		7. Мы возвращемся обратно в фрейм main.
			1. Указатель выходит из фрема printAll() И помечает его как не нужный. Для того чтобы JVM понимала что этот участок памяти можно перезаписывать.
			2. Происходит выделение и запись новой переменно сылочного типа, Которая ссылается на зарезервированный участок памяти String().
			3. Происходит вывод данных в консоль, то есть той переменной String.

		8. И в итоге если JVM решит что необходимо запустить GC - Garbage collector. То он приостанавливает всю программу целиком, начиная одну из двух своих основных тактик, это подсчет ссылок и обход графа достижимых объектов.
		Так как при работе фремаф printAll() Мы создали объект в памяти типа String.
		И у него больше нет ссылок из стэка, а сам он ссылается на ссылочный тип данных массив byte.
		То благодаря обходу достижимых графов, GC помечает эотот обеъект String как не используемый и выкидывает его из списка занятой памяти, возобнавляя работу программы.
