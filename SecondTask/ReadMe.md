# Задача "Исследование JVM через VisualVM"


```java
public static void main(String[] args) throws InterruptedException {
        System.out.println("Please open 'ru.netology.JvmExperience' in VisualVm");
        Thread.sleep(30_000);

        loadToMetaspaceAllFrom("io.vertx");
        Thread.sleep(3_000);
        loadToMetaspaceAllFrom("io.netty");
        Thread.sleep(3_000);
        loadToMetaspaceAllFrom("org.springframework");
        Thread.sleep(3_000);

        System.out.println(LocalTime.now() + ": now see heap");
        List<SimpleObject> simpleObjects = createSimpleObjects(5_000_000);
        Thread.sleep(3_000);
        simpleObjects.addAll(createSimpleObjects(5_000_000));
        Thread.sleep(3_000);
        simpleObjects.addAll(createSimpleObjects(5_000_000));
        Thread.sleep(3_000);
    }
```

### Необходимые графики:
	1. График Classes.
<img src="/Resources/ClassesT2.png"></img>

	2. График MetaSpace.
<img src="/Resources/MetaSpaceT2.png"></img>

	3. График HeapSpace.
<img src="/Resources/HeapMemT2.png"></img>

### Вывод консоли:
<img src="/Resources/ConsoleOutput.png"></img>


	1. Запуск программы 20:05:36 загружено 2038 классов.
		1. На этом этапе загружается все то что загружают Application, Platform и Bootsrap ClassLoader'ы.
<img src="/Resources/ClassesStartT2.png"></img>

		2. Так же на графике HeapSpace видно, что происходит изначальное резервирование памяти для классов.

		3. На графике MetaSpace видно, что память не используется вообще, потому что на этом этапе у нес нет никакой информации, так как нет никаких классов, методов, переменных. Это стартовая точка программы.

	2. 20:05:58 Можно увидеть по выводу в консоль, что начинается загрузка классов io.vertx, так же мы видим что было загружено 529 классов.
		1. На графике классов мы же видим, что количество классов с 2038, выросло до 2915.
			Что вероятнее всего связано с тем, что классы что были загружены из io.vertex, так же нуждаются еще в каких то своих классах, и подгружают их.
<img src="/Resources/ClassesT21.png"></img>

		2. Первые скачки на графике MetaSpace демонстрируют нам, что все те классы что были загружены, были сохранены в MetaSpace.

		3. Но по графику HeapMemory мы можем увидеть и понять, что занимаемая память выросла не сильно, так как в коде у нас появилось лишь пару объектов и переменных что на них ссылаются, так как все что мы сделали это загрузили классы, но не создавали их объектов.

	3. В 20:06:01 Мы видим, что начинается загрузка классов из покета io.netty и в 20:06:03 она заканчивается.
		1. На графике глассов мы видим, что количество их увеличивается до 4996.
			Но консоль нам говорит что было загружено 2117 классов. Это связано с тем, что у netty и у vertex один пакэйдж io и часть тех классов что нужны для io.netty уже бвли загружены во время загрузки io.vertex
<img src="/Resources/ClassesT22.png"></img>

		2. График HeapMemory продолжает плавать и не сильно рости, так как прибавилось еще пара переменных, какую то часть уже удалил GC.

		3. А вот уже график MetaSpace опять заметно вырос, но примернов половину, так как часть тех классов что необходима для netty, уже была загружена и сохранена, так что осталось лишь сохранить то чего еще не было.
<img src="/Resources/MetaSpaceT21.png"></img>

	4. 20:06:06 Начало загрузки org.springframework.
		1. Финальный рост на графике классов, количесвто которых выросло до 5888.
			Консоль же нам говорит что количесвто загруженных классов равно 869. Но не сложными математическими операциями мы понимаем что их количесвто выросло на 892. Все по тем же причинам что и выше описаны.
<img src="/Resources/ClassesT23.png"></img>

		2. MetaSpace же осталась на том же уровне что и была. Так как вся мета информация о классах, не увеличилась а осталась на том же уровне.
<img src="/Resources/MetaSpaceT22.png"></img>

		3. График HeapSpace все так же не особо меняется так как не добавляется новых объектов.

	5. 20:06:09 Создается 5_000_000 объектов, ссылки на которые записываются в List.

		1. Как мы помним наш график классов больше не менялся, ожидаемо так как никаких новых классов мы не использкем и не подгружаем.

		2. MetaSpace Заметно выросла, по той причине, что у нас создался List. Информацию о котором так же нужно записать.
<img src="/Resources/MetaSpaceT23.png"></img>

		3. На графике HeapMemory мы наконец видим рост, потому что под все созданные объекты JVM начинает резервировать память в куче.
<img src="/Resources/HeapMemoryT22.png"></img>

	6. 20:06:13 Создается еще 5_000_000 объектов, которые кладутся в List.

		1. Ожидаемо количество классов все так же не растет.

		2. MetaSpace тоже не меняется, так как лист уже создан и записан, больше нет того что необходимо сохранять.

		3. HeapMemory продолжает расти, так как под новые объекты JVM так же резервирует память в куче.
		Но память врыстает примерно в два раза больше чем в прошлый раз. Так как в методе createSimpleObjects() мы создаем list и в прошлый раз мы его присваивали, а теперь мы добавляем его в наш предыдущий первый созданный List.
		И это требует больше памяти и ресурсов процессора.
		Смею предположить что во время процесса работы метода addAll. JVM резервирует еще место под 5_000_000 объектов, которые уже будут присвоены этому листу.
<img src="/Resources/HeapMemoryT23.png"></img>


	7. 20:06:16 Операция схожая с предыдущей. И последствия такие же.

		1. Классы и MetaSpace остаются все в том же состоянии.

		2. HeapMemory вырастает в потреблении так же как и в прошлый раз, так как мы так же создаем новый лист, который потом добавляем через addAll.
		JVM резервирует место в памяти для копирывания объектов и присваивания их листу.
		И в конце мы видим легкое уменьшение памяти, так GC решил произвести очистку.
